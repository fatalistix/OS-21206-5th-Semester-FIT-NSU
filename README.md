# ФИТ НГУ 5 семестр (3 курс) 2023/2024 учебный год
## Лабораторные работы по операционным системам

Репозиторий подразделен по мере возможностей на подпункты, соответствующие пунктам задания из pdf. Нарушение наименований появляется только во 2 блоке.

## ПРОСЬБА!!!

Если мой репозиторий чем-то вам помог - прошу, поставьте звездочку). Вам несложно, мне приятно. Спасибо

## Сборка и комментарии

В зависимости от пункта задания "проекты" собираются по разному

### Блок 1
#### Оценка 3
Все файлы из данного блока собираются следующим образом:  
`gcc -o <executable_name> -lpthread <source_file_name>`

 - `gcc` можно заменить на `clang` (но это почему-то не очень одобряют на курсе)
 - можно добавить опциональные флаги на проверку ошибок `-Wall` или `-Wextra` и утечек `-fsanitize=address`
 - каждый `*.c` файл - отдельная программа и должна компилироваться независимо от других

#### Оценка 4
***ЭТО НЕ ИДЕАЛЬНАЯ РЕАЛИЗАЦИЯ БИБЛИОТЕКИ ПОТОКОВ ОПЕРАЦИОННОЙ СИСТЕМЫ***  
Из-за трудности реализации разрешено не реализовывать очистку памяти при уничтожении потока, так как это нетривиально.
Так же есть проблема с функцией `cancel` - она не останавливает поток, а просто заставляет его уйти в бесконечную обработку сигнала, тем самым **делая видимость** завершения работы.
Решил оставить так, чтобы сохранить вид, в котором было сдано преподавателю. Реализация функции `cancel` тоже является нетривиальной задачей (по крайней мере ее асинхронная реализация), возможным решением является реализация на ассемблерных вставках и метках.

Это уже проект, который можно собирать через CMake. `main.c` файл используется только для тестирования библиотеки и практической пользы не несет. Проект можно открыть с помощью любой IDE, понимающей CMake (Clion), и запустить уже из под нее, либо можно собрать исполняемый файл следующим образом:

 - Подразумевается, что вы находитесь уже в папке с проектом
 - `mkdir build` - создать папку `build`
 - `cd build` - зайти в папку `build`
 - `cmake ../CMakeLists.txt .` - подготовить файлы к сборке на основе `CMakeLists.txt` в текущуюю папку
 - `make` - собрать проект
 - `./main` - запустить проект

#### Оценка 5
Потоки в пользовательском пространстве пишутся гораздо проще. Планировщик работает по сигналу таймера раз в несколько милисекунд. Работает поверх одного потока. Собирается так же, как и в предыдущем пункте.

### Блок 2
#### Оценка 3
Запуск в 2.1:

 - `make`
 - `./<needed_executable>`

Запуск в 2.2 происходит в зависимости от содержимого:

 - Либо достаточно скомпилировать одиночный файл 
 - либо надо соединить файлы за исключением `*.h`

Единственное место, где проблема со структурой

#### Оценка 4
Точно так же, как в Блок 1 оценка 3

#### Оценка 5
##### my-spinlock
 - `gcc -o <executable_file> main.c my-spinlock.c my-spinlock.h -lpthread`
 - `./<executable_file>`

`-lpthread` обязателен, так как работоспособность проверяется аналогично как в оценке 4.

##### my-mutex
***Работает только при использовании `gcc`***  

 - `gcc -o <executable_file> main.c my-spinlock.c my-spinlock.h -lpthread`
 - `./<executable_file>`

`-lpthread` обязателен, так как работоспособность проверяется аналогично как в оценке 4.

### Блок 3
#### Оценка 5
Запуск аналогично Блок 1 оценка 4

Прокси работает не совсем так, как написано в тз:

 - Если запись в кэше не обнаружена, то новый поток не создается, вместо этого возвращается флаг того, что в кэше отсутствует запись, что означает, что SingleHostServer должен **сам** пойти за информацией и потом **обязательно** результат вернуть кэшеру.
 - Иногда при остановке прокси через Ctrl+C порт не освобождается сразу.
